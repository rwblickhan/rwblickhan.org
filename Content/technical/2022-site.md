# How I Built It: rwblickhan.org (2022)

```swift
struct RWBlickhanOrg: Website {
    enum SectionID: String, WebsiteSectionID {
        case books
        case films
        case recipes
        case stories
        case technical
        case tools
    }

    struct ItemMetadata: WebsiteItemMetadata {
        // Add any site-specific metadata that you want to use here.
    }

    var url = URL(string: "https://rwblickhan.org")!
    var name = "rwblickhan.org"
    var description = "A description of rwblickhan.org"
    var language: Language { .english }
    var imagePath: Path? { "/images/coverimage.png" }
}
```


Publish divides content into **items**, **sections**, freeform **pages**, and a single main **index** page. All of the content lives in Markdown files in the `Content` directory. 

> xcxc

Each section needs a `SectionID`, although to be honest I don’t know what Publish uses it for internally. You can also add `ItemMetadata` like publish date, which is pulled from the Markdown frontmatter, but I don’t use that.

I also have to define some constants Publish uses internally, like a reference to the base `url` of the site so Publish can statically replace relative links with absolute links (`/images` -\> `https://rwblickhan.org/images`, for example).

```swift
try RWBlickhanOrg().publish(
    at: nil,
    using: [
        .installPlugin(.pygments()),
        .optional(.copyResources()),
        .addMarkdownFiles(),
        .sortItems(by: \.date, order: .descending),
        .generateHTML(withTheme: .rwblickhan, indentation: nil),
        .step(named: "Apply Tailwind") { _ in
            try shellOut(
                to: "npx tailwindcss -i ./Resources/theme/styles.css -o ./Output/theme/styles.css -c tailwind.config.js")
        },
        .generateSiteMap(indentedBy: nil),
        .unwrap(.s3("rwblickhan.org"), PublishingStep.deploy),
    ])
```

Publish runs `main.swift` as a script. All this script does is create an instance of the `RWBlickhanOrg` struct defined above and `publish()` it.

`publish()` takes a parameter that defines the steps in the publishing pipeline. Most of these are pretty self-explanatory, but a few are interesting:

* `. installPlugin(.pygments())` installs the Pygments syntax highlighter plugin.
* `.generateHTML(withTheme: .rwblickhan, indentation: nil)` generates the HTML from the templates I wrote, which I’ll cover momentarily.
* `.step(named: "Apply Tailwind")` is a custom command I wrote. After generating the HTML in the `Output/` folder, this step calls the Tailwind CSS CLI tool to produce the final CSS that will be sent to clients.
* `.unwrap(.s3("rwblickhan.org"), PublishingStep.deploy)` uses another plugin to publish the contents of the `Output/` folder to an S3 bucket.

Moving on to `theme.swift`, we start out with:

```swift
private struct RWBlickhanOrgHTMLFactory<Site: Website>: HTMLFactory {
    func makeIndexHTML(for index: Index, context: PublishingContext<Site>) throws -> HTML {
        ...
    }

    func makeSectionHTML(for section: Section<Site>, context: PublishingContext<Site>) throws -> HTML {
		...
	}

	func makeItemHTML(for item: Item<Site>, context: PublishingContext<Site>) throws -> HTML {
		...
	}

	func makePageHTML(for page: Page, context: PublishingContext<Site>) throws -> HTML {
		...
	}
```

Publish is built with the Plot HTML templating engine, which exposes a core `HTML` type. Each of these functions produces a template for a type of page, filled in with the details of the parsed Markdown, which Plot can then convert to HTML. For instance:

```swift
func makeIndexHTML(for index: Index, context: PublishingContext<Site>) throws -> HTML {
	HTML(
		.lang(context.site.language),
		.head(for: index, on: context.site, stylesheetPaths: [
			"/theme/styles.css",
			"/theme/pygments.css",
			"/theme/Vollkorn/vollkorn.css",
		]),
		.body(
			.header(for: context.site),
            .main(
                .div(
                    makeStandardBodyClass(),
                    .contentBody(index.body)))))
}
```

In Plot, HTML elements are mapped straightforwardly to typesafe Swift enums. In this case, we let Plot generate a standard `<head>` element, with the addition of our custom CSS. Then we add a `<body>` made up of a header (produced by a helper function) and a semantic `<main>`  element wrapping a `<div>`, which just contains `index.body` (the parsed Markdown) and some styling. The styling is produced by a helper function:

```swift
private func makeStandardBodyClass() -> Node<HTML.BodyContext> {
    let layoutProps = "pt-32 mb-8 mx-4 md:max-w-3xl md:mx-auto"
    let typographyProps = "prose dark:prose-invert"
    let linkTypographyProps = "prose-a:text-rwb-blue-light dark:prose-a:text-rwb-blue-dark prose-a:no-underline hover:prose-a:underline"
    return .class("\(layoutProps) \(typographyProps) \(linkTypographyProps)")
}
```

This uses Tailwind’s utility classes to define the layout, colors, and typography for the main body text. I’ve split it into multiple, concatenated strings because Tailwind tends to produce extremely large sets of CSS classes.

`layoutProps` contains the main layout props. `pt-32` adds padding at the top to avoid the header. `mb-8` and `mx-4` add a bit of margin to the other edges, which is mostly for small devices where the text goes edge to edge. On medium-size screens and larger (`md` in Tailwind parlance), I set `max-w-3xl` to limit the text to a reasonable line length and `mx-auto` to center the text horizontally.

`typographyProps` enables the [typography plugin][1] with `prose` or, in dark mode, `prose-invert`. That provides reasonable typographic defaults for any text in the body.

`linkTypographyProps` overrides the typography plugin’s defaults for link (`<a>` tag) rendering. I use a standard `rwb-blue-light` for link text color, with a slightly darker `rwb-blue-dark` in dark mode. I also set `no-underline` unless the cursor is hovering over a link.

The custom colors are defined in `tailwind.config.js`:

```js
module.exports = {
  theme: {
    extend: {
      colors: {
        'rwb-blue-light': '#3366cc',
        'rwb-blue-dark': '#2e5cb8',
        ...
      }
    },
    ...
  },
  ...
}
```

The header, meanwhile, is also produced by a helper function:

```swift
private extension Node where Context == HTML.BodyContext {
    static func header<T: Website>(for _: T) -> Node {
        .header(
            .div(
                .class("bg-black absolute md:fixed h-24 top-0 inset-x-0 flex items-center justify-between"),
                .a(
                    .class("ml-4 md:ml-12 text-white text-4xl no-underline hover:underline"),
                    .text("rwblickhan.org"),
                    .href("/index.html"))))
    }
}
```

There’s some boilerplate here to make this work in Swift, but essentially this is just defining a semantic `<header>` wrapping a `<div>`. We style that with a black background and an `absolute` position, unless we’re on a medium-sized screen, in which case we position it as `fixed` so that the header doesn’t scroll away. It has some sizing constraints and it’s `flex` so that its contents are automatically laid out.

Right now, though, the only content is a single `<a>` tag on the left of the screen, which has a white text color but otherwise matches 

[1]:	https://tailwindcss.com/docs/typography-plugin